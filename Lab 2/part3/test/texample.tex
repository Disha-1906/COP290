\input{setup/preamble.tex}
\input{setup/macros.tex}

% \documentclass{standalone}

\usepackage{pgfplots}

\pgfplotsset{compat = newest}

\begin{document}


    \name{COP290 LAB 2}{PART 1 : Storing and Restoring Contexts in C}
    

 
    \para{In this part of the code we learnt basics of storing, restoring and switching between the contexts and the basic functionalities of setcontext() and  getcontext() functions. We implemented a C program to run the conjecture function by switching two contexts. Below is the detailed explaination of our code :}
    
    \para{\textbf{Conjecture Function :}  It takes as input an array of integers, a size, and a function pointer. The function pointer points to the app function, which will be called for each element in the array. The conjecture function creates two contexts using the ucontext library. The first context, ctx[0], is used to return to the main function after the algorithm has finished. The second context, ctx[1], is used to call the app function for each element in the array. The context is set up with a stack of 8192 bytes, and it points to the first context as its link.}
    
    \para{\textbf{App Function :} takes an integer pointer as its argument and uses the assert function to check whether the integer is less than 40 and not a prime number. If the assertion fails, the context is switched back to ctx[1], and the next element in the array is processed. If the assertion succeeds, the nested function is called with the integer as its argument, and its result is printed to the console.}

    \para{\textbf{Nested Function :} takes an integer as its argument and checks whether it is prime. If it is, the assert function is called to switch the context back to ctx[1]. If it is not prime, the square of the integer is returned.}

    \para{\textbf{Main Function :}creates an array of integers, mynums, and calls the conjecture function with the array, the size of each element in the array, and the function pointer to app.}

    \para{In summary, the code implements a switching and restoring ctx[0] and ctx[1] depending on the return value of assert function. The algorithm uses the ucontext library to create contexts for each element in an array, and it uses the assert function to switch contexts when necessary. The algorithm stops when all elements in the array have been processed, and it returns to the main function.}
    \para{In summary, the code implements a switching and restoring ctx[0] and ctx[1] depending on the return value of assert function. The algorithm uses the ucontext library to create contexts for each element in an array, and it uses the assert function to switch contexts when necessary. The algorithm stops when all elements in the array have been processed, and it returns to the main function.}
    \para{In summary, the code implements a switching and restoring ctx[0] and ctx[1] depending on the return value of assert function. The algorithm uses the ucontext library to create contexts for each element in an array, and it uses the assert function to switch contexts when necessary. The algorithm stops when all elements in the array have been processed, and it returns to the main function.}
    \para{In summary, the code implements a switching and restoring ctx[0] and ctx[1] depending on the return value of assert function. The algorithm uses the ucontext library to create contexts for each element in an array, and it uses the assert function to switch contexts when necessary. The algorithm stops when all elements in the array have been processed, and it returns to the main function.}

    \name{PART 2 : Concurrency and Threads in C}
    

 
    \para{In this part of the code we created data structures- lists, hashmaps and threads from scratch. We implemented a C program to find the count of every word summed across all the files once using a single thread and once using multithreads. Below is the detailed explanation of our code :}

    \section{List}
    \para{The code defines a doubly linked list data structure with basic operations such as adding, removing, and checking if the list is empty. The list structure is implemented using two structs, list and listentry, which are used to represent the list as a whole and each entry in the list, respectively.}
    
    \para{\textbf{List rm :} It is used to remove an entry from the list, given a pointer to the list and the entry to be removed. The function traverses the list using a pointer to the head, and if the entry to be removed is the head, the next entry is set as the new head, and the memory allocated to the removed entry is freed. Otherwise, the function searches the list for the entry, and if found, updates the prev and next pointers of the adjacent entries to remove the entry from the list and then frees the memory allocated to the removed entry.}

    \para{\textbf{List add :} It is used to add a new entry to the list, given a pointer to the list and the data to be stored in the new entry. The function first allocates memory for the new entry using malloc, sets its prev and next pointers to the current tail of the list and NULL, respectively, and sets its data pointer to the provided data. The function then updates the next pointer of the current tail, sets the new entry as the new tail, and if the head of the list is empty, sets the new entry as the new head. Finally, the function returns a pointer to the new entry.}

    \para{\textbf{List new  :} It returns a new empty list with head and tail set to NULL.}

    \para{\textbf{Is empty :} It takes a pointer to a list as input and returns 1 if the list is empty, and 0 otherwise. The function checks whether the head of the list is NULL or not and returns the appropriate value.}
    
    \para{Overall, this code provides a basic implementation of a doubly linked list, which can be used to store and manipulate data in an ordered manner.}

    \section{Hashmap}
    
    \para{The given code implements a hashmap data structure in C and provides basic operations such as creation, insertion, retrieval, iteration, and locking on a per-bucket basis. The code consists of the following functions:}
    
    \para{\textbf{Hashmap create: }It initializes a new hashmap by allocating memory for SZ number of linked lists and locks. It returns 0 on success and -1 on failure.}

    \para{\textbf{Hash function: }It is a user-defined hash function that generates a hash value for the given key string. It uses a simple algorithm of iterating over each character of the key and adding it to a running hash value. The final hash value is obtained by modulo operation with SZ, which is the size of the hashmap. 
    }

    \para{\textbf{Hashmap put :}It adds a new key-value pair to the hashmap. It first calculates the hash value of the given key using the hash function and then checks if the key already exists in the hashmap by iterating over the linked list in the corresponding bucket. If the key is found, its value is updated to the new data. If the key is not found, a new hashmap element s struct is created and added to the linked list.}

    \para{\textbf{Hashmap get :}It retrieves the value corresponding to the given key from the hashmap. It calculates the hash value of the key and iterates over the linked list in the corresponding bucket to find the hashmap element s struct containing the key. If the key is found, its value is returned. If the key is not found, NULL is returned.}

    \para{\textbf{Hashmap iterator :}It iterates over all the linked lists in the hashmap and executes the given function f on each hashmap element s struct. The purpose of this function is to provide a way to iterate over all key-value pairs in the hashmap}

    \para{\textbf{Acquire bucket :}It acquires a lock on the corresponding bucket of the given key. It calculates the hash value of the key and acquires the lock associated with the corresponding bucket}

    \para{\textbf{Release bucket :}It releases the lock acquired by acquire bucket on the corresponding bucket of the given key. It calculates the hash value of the key and releases the lock associated with the corresponding bucket.}

    \para{Overall, the code implements a basic hashmap data structure with locking support.}

     \section{Threads}
      \para{In this section, we have implemented thread management using ucontext library in C language. It provides a mechanism to create, manage, and switch between threads. Additionally, it also includes functions to implement thread synchronization using locks.
      The code defines a Thread structure that consists of a ucontext t type variable representing the context of the thread and pointers to the previous and next threads. It also defines a mythread structure that contains pointers to the head, tail, and current threads.}

     \para{\textbf{mythread init() : } It initializes the mythread arr structure. mythread create() function creates a new thread and adds it to the end of the thread list. It creates a new context for the thread and sets the function and argument to be executed. The function also sets the current thread to the new thread if there is no current thread.}
    \para{\textbf{remove thread() :} It removes the given thread from the thread list. mythread yield() function performs the context switching between threads. It saves the current context and restores the context of the next thread to be executed. The current thread is set to the next thread.}
    \para{\textbf{mythread join() : } It waits for the execution of all the threads in the thread list. It uses context switching to switch to the next thread and removes the completed threads from the thread list.}
    \para{\textbf{mythread yield :} It performs a context switch to the next thread in the linked list. It updates the current thread pointer and swaps the contexts using the swapcontext function.}

    \para{\textbf{Comparison between multiple and single thread results and examining the correctness of results}}

\para{Using our custom thread library and hashmap, we solved the problem of finding the count of every word summed across N text files. We observed inaccurate results. The word count observed for a given word was less than the actual count. This must be due to multiple threads accessing the same file simultaneously leading to race conditions. }


\para{\textbf{Does the output vary on yielding? Why do you think the output varies?}}
\para{Yielding threads can increase runtime because it involves a context switch, which can introduce overhead and cause the processor to spend more time switching between threads rather than executing the actual tasks.

When a thread yields, it gives up the CPU to allow other threads to execute. This involves the operating system saving the current thread's state, such as the current instruction pointer and stack, and restoring the state of the next thread to run. This context switch can introduce overhead and additional processing time, especially if there are many threads competing for CPU time.

Furthermore, if the threads are synchronized and dependent on each other's results, yielding can also introduce additional overhead because it can cause delays in the synchronization process. For example, if a thread needs to wait for another thread's output before continuing, yielding that thread may delay the synchronization process and increase the overall runtime.

Therefore, while yielding threads can be useful for allowing multiple threads to execute in a fair and cooperative manner, it can also introduce overhead and potentially increase the overall runtime of a program.}

\para{\textbf{lock new :} It creates a new lock and returns its pointer.}
\para{\textbf{lock acquire : } It implements a basic spin lock where a thread keeps waiting until the lock is acquired by another thread.}
\para{\textbf{lock release :} It releases the lock by setting its context to NULL.}

\para{\textbf{Effect of using locks}}

    
    \para{The lock is used to prevent multiple threads from accessing the same critical section of code simultaneously.}
    \para{Without a lock, multiple threads can access the critical section of code simultaneously, leading to race conditions and unpredictable behavior. This can result in threads overwriting each other's data or performing operations out of order, which can lead to incorrect output.
By using a lock, only one thread is allowed to access the critical section at a time. This ensures that the code is executed in a predictable and consistent way, which can lead to more reliable and consistent output. However, it can also result in longer execution times if threads are frequently waiting for the lock to become available.}



 \name{PART 3 : pThreads}    
    \para{\textbf{Comparative analysis between the runtimes of part 2 and part 3 :} We observed that the runtime of part 3 was faster than part 2 for large input files. We also observed that the runtime increased with an increase in the number of input files and the size of input files. If each file has the same word repeated many times, the runtime will increase as the hashmap would be larger.}
    \para{\textbf{Differences in speed} can be attributed to the use of the pthread library in part 3, which is a more optimized and efficient library than our custom thread library in part 2. This library implements parallelism and performs different tasks simultaneously. }

\pgfplotstableread{size.dat}{\table}

\begin{tikzpicture}

\begin{axis}[
    xmin = 0, xmax = 260,
    ymin = 0.00 , ymax = 15.00,
    xtick distance = 25,
    ytick distance = 1.0,
    grid = both,
    minor tick num = 1,
    major grid style = {lightgray},
    minor grid style = {lightgray!25},
    width = \textwidth,
    height = 0.75\textwidth,
    xlabel = {$Size of files (in KB)$},
    ylabel = {$Time (in sec)$},
    legend cell align = {left},
    legend pos = north west]
\addplot[blue, mark = *] table [x = {x}, y = {y1}] {\table};

\addplot[red, mark =  *] table [x ={x}, y = {y2}] {\table};


\legend{
    Plot using our thread library ,
    Plot using pthreads,
}




\end{axis}

\end{tikzpicture}

\begin{center}
\begin{tabular}{ |c|c|c| } 
 \hline
 Size of input files & Time elapsed using our thread library & Time elapsed using pthread \\
  \hline \hline
24.3 & 0.277 & 0.185 \\
 \hline
50.6 & 0.755 & 0.394 \\
 \hline
74.8 & 1.590 & 0.550 \\
 \hline
101.1 & 2.576 & 0.770 \\
 \hline
125.3 & 3.978 & 0.910 \\
 \hline
151.7 & 5.463 & 1.065 \\
 \hline
175.9 & 7.418 & 1.228 \\
 \hline
202.2 & 9.498 & 1.417 \\
 \hline
226.5 & 11.792 & 1.577 \\
 \hline
252.9 & 13.472 & 1.811 \\
 \hline
\end{tabular}
\end{center}
\pgfplotstableread{number.dat}{\table}

\begin{tikzpicture}

\begin{axis}[
    xmin = 0, xmax = 15,
    ymin = 0.00 , ymax = 10.00,
    xtick distance = 1,
    ytick distance = 0.1,
    grid = both,
    minor tick num = 1,
    major grid style = {lightgray},
    minor grid style = {lightgray!25},
    width = \textwidth,
    height = 1.8\textwidth,
    xlabel = {$Number of input files$},
    ylabel = {$Time (in sec)$},
    legend cell align = {left},
    legend pos = north west]
\addplot[blue, mark = *] table [x = {x}, y = {y1}] {\table};

\addplot[red, mark =  *] table [x ={x}, y = {y2}] {\table};


\legend{
    Plot using our thread library ,
    Plot using pthreads,
}




\end{axis}

\end{tikzpicture}
\begin{center}
\begin{tabular}{ |c|c|c| }
\hline
 No. of input files & Time elapsed using our thread library & Time elapsed using pthread \\
  \hline \hline
3 & 0.278 & 0.185 \\
 \hline
4 & 0.499 & 0.224 \\
 \hline
5 & 0.887 & 0.264 \\
 \hline
6 & 1.430 & 0.299 \\
 \hline
7 & 2.180 & 0.304 \\
 \hline
8 & 3.225 & 0.314 \\
 \hline
9 & 4.456 & 0.326 \\
 \hline
10 & 6.052 & 0.337 \\
 \hline
11 & 7.203 & 0.377 \\
 \hline
12 & 7.996 & 0.380 \\
\hline
13 & 8.458 & 0.402 \\
 \hline
\end{tabular}
\end{center}
\end{document}
